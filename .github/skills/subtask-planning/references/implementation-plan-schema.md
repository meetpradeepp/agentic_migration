# Implementation Plan Schema

This document defines the structure of implementation plans generated by the subtask-planning skill.

## Schema

```json
{
  "workflow_type": "FEATURE | REFACTOR | INVESTIGATION | MIGRATION | SIMPLE",
  "specification_id": "F001 | B001 | I001 | M001",
  "title": "Human-readable title",
  "description": "Brief description of the work",
  "phases": [
    {
      "phase_id": 0,
      "phase_name": "INVESTIGATION",
      "purpose": "Why this phase exists",
      "entry_criteria": ["What must be true to start"],
      "exit_criteria": ["What must be true to complete"],
      "subtasks": [
        {
          "subtask_id": "P0-T1",
          "service": "service-name",
          "title": "What this subtask does",
          "description": "Detailed description",
          "files_to_modify": ["path/to/file.ts"],
          "dependencies": ["P0-T0"],
          "verification_steps": [
            "Specific test or check to verify completion"
          ],
          "estimated_complexity": "LOW | MEDIUM | HIGH",
          "notes": ["Additional context or warnings"]
        }
      ]
    }
  ],
  "global_considerations": {
    "security": ["Security concerns to address"],
    "performance": ["Performance considerations"],
    "backwards_compatibility": ["Compatibility requirements"],
    "rollback_strategy": "How to undo changes if needed"
  },
  "verification_strategy": {
    "unit_tests": ["What to test"],
    "integration_tests": ["What to test"],
    "manual_verification": ["What to check manually"]
  }
}
```

## Field Descriptions

### Root Level

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `workflow_type` | Enum | Yes | Type of work: FEATURE, REFACTOR, INVESTIGATION, MIGRATION, SIMPLE |
| `specification_id` | String | Yes | Unique identifier from specification file |
| `title` | String | Yes | Human-readable title |
| `description` | String | Yes | Brief description of the overall work |
| `phases` | Array | Yes | Array of phase objects |
| `global_considerations` | Object | Yes | Cross-cutting concerns |
| `verification_strategy` | Object | Yes | Overall testing strategy |

### Phase Object

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `phase_id` | Integer | Yes | Unique phase identifier (0-indexed) |
| `phase_name` | String | Yes | Descriptive phase name |
| `purpose` | String | Yes | Why this phase exists |
| `entry_criteria` | Array | No | Conditions required to start phase |
| `exit_criteria` | Array | No | Conditions that complete the phase |
| `subtasks` | Array | Yes | Array of subtask objects |

### Subtask Object

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `subtask_id` | String | Yes | Unique identifier (format: P{phase}-T{task}) |
| `service` | String | Yes | Service name (one service per subtask) |
| `title` | String | Yes | What this subtask does |
| `description` | String | Yes | Detailed description |
| `files_to_modify` | Array | Yes | List of file paths (1-3 max) |
| `dependencies` | Array | Yes | Array of subtask_ids this depends on (can be empty) |
| `verification_steps` | Array | Yes | Specific checks to verify completion |
| `estimated_complexity` | Enum | Yes | LOW, MEDIUM, or HIGH |
| `notes` | Array | No | Additional context, warnings, or tips |

### Global Considerations Object

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `security` | Array | No | Security concerns to address |
| `performance` | Array | No | Performance considerations |
| `backwards_compatibility` | Array | No | Compatibility requirements |
| `rollback_strategy` | String | No | How to undo changes if needed |

### Verification Strategy Object

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `unit_tests` | Array | Yes | Unit tests to create/update |
| `integration_tests` | Array | Yes | Integration tests to create/update |
| `manual_verification` | Array | No | Manual checks required |

## Constraints

### Phase Constraints

1. **Phase 0 Mandatory**: Every plan must have Phase 0 (INVESTIGATION)
2. **Sequential IDs**: Phase IDs must be sequential integers starting at 0
3. **Logical Grouping**: Phases should group related subtasks

### Subtask Constraints

1. **One Service**: Each subtask must focus on exactly one service
2. **File Limit**: Maximum 1-3 files per subtask
3. **Unique IDs**: Subtask IDs must be unique across all phases
4. **ID Format**: Must follow pattern `P{phase_id}-T{task_number}`
5. **Valid Dependencies**: All dependency references must exist
6. **No Circular Dependencies**: Dependency graph must be a DAG

### Dependency Constraints

1. **Same Phase or Earlier**: Can only depend on subtasks in same phase or earlier phases
2. **No Self-Dependencies**: Subtask cannot depend on itself
3. **DAG Structure**: Overall dependency graph must be acyclic
4. **Service Boundaries**: Cross-service dependencies should be minimized

## Validation Rules

### Required Validations

```javascript
// Example validation checks
function validatePlan(plan) {
  // 1. Phase 0 exists
  assert(plan.phases[0].phase_id === 0);
  assert(plan.phases[0].phase_name === "INVESTIGATION");
  
  // 2. Subtask IDs are unique
  const ids = plan.phases.flatMap(p => p.subtasks.map(s => s.subtask_id));
  assert(new Set(ids).size === ids.length);
  
  // 3. All dependencies exist
  for (const phase of plan.phases) {
    for (const subtask of phase.subtasks) {
      for (const dep of subtask.dependencies) {
        assert(ids.includes(dep));
      }
    }
  }
  
  // 4. One service per subtask
  for (const phase of plan.phases) {
    for (const subtask of phase.subtasks) {
      assert(subtask.service && subtask.service.length > 0);
    }
  }
  
  // 5. File count limit
  for (const phase of plan.phases) {
    for (const subtask of phase.subtasks) {
      assert(subtask.files_to_modify.length >= 1);
      assert(subtask.files_to_modify.length <= 3);
    }
  }
  
  // 6. No circular dependencies
  assert(isDAG(buildDependencyGraph(plan)));
}
```

## Examples

### Minimal Valid Plan

```json
{
  "workflow_type": "SIMPLE",
  "specification_id": "F001",
  "title": "Add logging to API",
  "description": "Add structured logging to user API endpoints",
  "phases": [
    {
      "phase_id": 0,
      "phase_name": "INVESTIGATION",
      "purpose": "Review current logging setup",
      "subtasks": [
        {
          "subtask_id": "P0-T1",
          "service": "user-api",
          "title": "Review logging configuration",
          "description": "Check logger setup and configuration",
          "files_to_modify": ["src/config/logger.ts"],
          "dependencies": [],
          "verification_steps": ["Confirm logger library and settings"],
          "estimated_complexity": "LOW"
        }
      ]
    },
    {
      "phase_id": 1,
      "phase_name": "Implementation",
      "purpose": "Add logging to endpoints",
      "subtasks": [
        {
          "subtask_id": "P1-T1",
          "service": "user-api",
          "title": "Add logging to user endpoints",
          "description": "Add structured logging to CRUD endpoints",
          "files_to_modify": ["src/controllers/userController.ts"],
          "dependencies": ["P0-T1"],
          "verification_steps": [
            "Check logs appear in console",
            "Verify log format matches standards"
          ],
          "estimated_complexity": "LOW"
        }
      ]
    }
  ],
  "global_considerations": {
    "security": ["Ensure no PII in logs"],
    "performance": ["Log level should be configurable"],
    "backwards_compatibility": [],
    "rollback_strategy": "Remove logging statements"
  },
  "verification_strategy": {
    "unit_tests": ["Test logging output format"],
    "integration_tests": ["Verify logs in test environment"],
    "manual_verification": ["Review logs in local development"]
  }
}
```

### Complex Multi-Phase Plan

See [complete example](../examples/feature-avatar-upload.json)

## Usage

### Reading Plans

```typescript
import { readFile } from 'fs/promises';

async function loadPlan(planPath: string) {
  const content = await readFile(planPath, 'utf-8');
  const plan = JSON.parse(content);
  
  // Validate
  validatePlan(plan);
  
  return plan;
}
```

### Executing Plans

```typescript
async function executePlan(plan: ImplementationPlan) {
  for (const phase of plan.phases) {
    console.log(`Starting Phase ${phase.phase_id}: ${phase.phase_name}`);
    
    // Check entry criteria
    if (phase.entry_criteria) {
      await verifyEntryCriteria(phase.entry_criteria);
    }
    
    // Execute subtasks respecting dependencies
    await executePhaseWithDependencies(phase);
    
    // Check exit criteria
    if (phase.exit_criteria) {
      await verifyExitCriteria(phase.exit_criteria);
    }
  }
}
```

## See Also

- [Feature workflow](./workflow-feature.md)
- [Refactor workflow](./workflow-refactor.md)
- [Investigation workflow](./workflow-investigation.md)
- [Migration workflow](./workflow-migration.md)
- [Example plans](../examples/)
